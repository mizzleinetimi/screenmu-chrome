// Keyframe merging utilities for Phase 3 Timeline Editing
// LLM Disclosure: This file was generated with AI assistance.
// See steering.md: TypeScript Rules - No any, no type casting with as.

import type { ZoomMarker, Viewport, NormalizedCoord } from '../types';

// ============================================================================
// Constants
// ============================================================================

/**
 * Timestamp tolerance in microseconds for considering two keyframes as "same timestamp".
 * Keyframes within this threshold will be considered overlapping, and manual takes precedence.
 * 100ms = 100,000 microseconds - reasonable tolerance for user-placed keyframes.
 */
export const KEYFRAME_TIMESTAMP_TOLERANCE_US = 100_000;

// ============================================================================
// Keyframe Merge Types
// ============================================================================

/**
 * Source type for a keyframe - used to track origin for debugging/display.
 */
export type KeyframeSource = 'auto' | 'manual';

/**
 * Extended keyframe with source tracking.
 */
export interface KeyframeWithSource extends ZoomMarker {
  source: KeyframeSource;
}

// ============================================================================
// Keyframe Merge Functions
// ============================================================================

/**
 * Merges manual keyframes with auto-generated keyframes.
 * Manual keyframes take precedence when they have the same (or very close) timestamp
 * as auto-generated keyframes.
 *
 * Algorithm:
 * 1. Mark all keyframes with their source (auto/manual)
 * 2. For each manual keyframe, remove any auto keyframes within the tolerance threshold
 * 3. Combine remaining auto keyframes with all manual keyframes
 * 4. Sort by timestamp
 *
 * @param autoKeyframes - Keyframes generated by the engine
 * @param manualKeyframes - Keyframes manually created/edited by the user
 * @param toleranceUs - Timestamp tolerance in microseconds (default: 100ms)
 * @returns Merged keyframes sorted by timestamp, with manual taking precedence
 *
 * Validates: Requirement 1.9 - Manual keyframe edits SHALL override auto-generated keyframes
 */
export function mergeKeyframes(
  autoKeyframes: ZoomMarker[],
  manualKeyframes: ZoomMarker[],
  toleranceUs: number = KEYFRAME_TIMESTAMP_TOLERANCE_US
): ZoomMarker[] {
  // Handle edge cases
  if (manualKeyframes.length === 0) {
    return [...autoKeyframes].sort((a, b) => a.timestamp - b.timestamp);
  }
  if (autoKeyframes.length === 0) {
    return [...manualKeyframes].sort((a, b) => a.timestamp - b.timestamp);
  }

  // Filter out auto keyframes that are within tolerance of any manual keyframe
  const filteredAutoKeyframes = autoKeyframes.filter((autoKf) => {
    return !isOverriddenByManual(autoKf.timestamp, manualKeyframes, toleranceUs);
  });

  // Combine filtered auto keyframes with all manual keyframes
  const merged = [...filteredAutoKeyframes, ...manualKeyframes];

  // Sort by timestamp
  return merged.sort((a, b) => a.timestamp - b.timestamp);
}

/**
 * Merges keyframes and preserves source information for each keyframe.
 * Useful for UI display where you want to show which keyframes are manual vs auto.
 *
 * @param autoKeyframes - Keyframes generated by the engine
 * @param manualKeyframes - Keyframes manually created/edited by the user
 * @param toleranceUs - Timestamp tolerance in microseconds (default: 100ms)
 * @returns Merged keyframes with source tracking, sorted by timestamp
 *
 * Validates: Requirement 1.9
 */
export function mergeKeyframesWithSource(
  autoKeyframes: ZoomMarker[],
  manualKeyframes: ZoomMarker[],
  toleranceUs: number = KEYFRAME_TIMESTAMP_TOLERANCE_US
): KeyframeWithSource[] {
  // Handle edge cases
  if (manualKeyframes.length === 0) {
    return autoKeyframes
      .map((kf) => ({ ...kf, source: 'auto' as KeyframeSource }))
      .sort((a, b) => a.timestamp - b.timestamp);
  }
  if (autoKeyframes.length === 0) {
    return manualKeyframes
      .map((kf) => ({ ...kf, source: 'manual' as KeyframeSource }))
      .sort((a, b) => a.timestamp - b.timestamp);
  }

  // Filter out auto keyframes that are within tolerance of any manual keyframe
  const filteredAutoKeyframes = autoKeyframes
    .filter((autoKf) => !isOverriddenByManual(autoKf.timestamp, manualKeyframes, toleranceUs))
    .map((kf) => ({ ...kf, source: 'auto' as KeyframeSource }));

  // Add source to manual keyframes
  const manualWithSource = manualKeyframes.map((kf) => ({
    ...kf,
    source: 'manual' as KeyframeSource,
  }));

  // Combine and sort
  const merged = [...filteredAutoKeyframes, ...manualWithSource];
  return merged.sort((a, b) => a.timestamp - b.timestamp);
}

/**
 * Checks if a timestamp is overridden by any manual keyframe.
 * A timestamp is considered overridden if there's a manual keyframe within the tolerance.
 *
 * @param timestamp - Timestamp to check (in microseconds)
 * @param manualKeyframes - List of manual keyframes
 * @param toleranceUs - Timestamp tolerance in microseconds
 * @returns True if the timestamp is within tolerance of any manual keyframe
 */
export function isOverriddenByManual(
  timestamp: number,
  manualKeyframes: ZoomMarker[],
  toleranceUs: number = KEYFRAME_TIMESTAMP_TOLERANCE_US
): boolean {
  return manualKeyframes.some((manualKf) => {
    const diff = Math.abs(manualKf.timestamp - timestamp);
    return diff <= toleranceUs;
  });
}

/**
 * Finds the nearest keyframe to a given timestamp.
 * Useful for snapping operations or finding the keyframe to edit.
 *
 * @param timestamp - Target timestamp in microseconds
 * @param keyframes - List of keyframes to search
 * @returns The nearest keyframe, or null if the list is empty
 */
export function findNearestKeyframe(
  timestamp: number,
  keyframes: ZoomMarker[]
): ZoomMarker | null {
  if (keyframes.length === 0) {
    return null;
  }

  let nearest = keyframes[0];
  let minDiff = Math.abs(keyframes[0].timestamp - timestamp);

  for (let i = 1; i < keyframes.length; i++) {
    const diff = Math.abs(keyframes[i].timestamp - timestamp);
    if (diff < minDiff) {
      minDiff = diff;
      nearest = keyframes[i];
    }
  }

  return nearest;
}

/**
 * Checks if two keyframes are at the same timestamp (within tolerance).
 *
 * @param kf1 - First keyframe
 * @param kf2 - Second keyframe
 * @param toleranceUs - Timestamp tolerance in microseconds
 * @returns True if keyframes are within tolerance of each other
 */
export function areKeyframesAtSameTimestamp(
  kf1: ZoomMarker,
  kf2: ZoomMarker,
  toleranceUs: number = KEYFRAME_TIMESTAMP_TOLERANCE_US
): boolean {
  return Math.abs(kf1.timestamp - kf2.timestamp) <= toleranceUs;
}

/**
 * Counts how many auto keyframes would be overridden by manual keyframes.
 * Useful for UI feedback showing the impact of manual edits.
 *
 * @param autoKeyframes - Keyframes generated by the engine
 * @param manualKeyframes - Keyframes manually created/edited by the user
 * @param toleranceUs - Timestamp tolerance in microseconds
 * @returns Number of auto keyframes that would be overridden
 */
export function countOverriddenKeyframes(
  autoKeyframes: ZoomMarker[],
  manualKeyframes: ZoomMarker[],
  toleranceUs: number = KEYFRAME_TIMESTAMP_TOLERANCE_US
): number {
  return autoKeyframes.filter((autoKf) =>
    isOverriddenByManual(autoKf.timestamp, manualKeyframes, toleranceUs)
  ).length;
}


// ============================================================================
// Viewport Interpolation Functions
// ============================================================================

/**
 * Interpolates viewport from zoom markers at a given timestamp.
 * Uses linear interpolation between adjacent keyframes.
 *
 * Algorithm:
 * - If no keyframes: return default viewport (center 0.5,0.5, zoom 1.0)
 * - If single keyframe: return that keyframe's viewport
 * - If timestamp before first keyframe: return first keyframe's viewport
 * - If timestamp after last keyframe: return last keyframe's viewport
 * - Otherwise: linear interpolation between adjacent keyframes
 *
 * @param keyframes - Array of zoom markers (should be sorted by timestamp)
 * @param timestamp - Target timestamp in microseconds
 * @returns Interpolated viewport at the given timestamp
 *
 * Validates: Requirement 1.7 - Preview SHALL update in real-time to show new zoom behavior
 */
export function interpolateViewportFromKeyframes(
  keyframes: ReadonlyArray<ZoomMarker>,
  timestamp: number
): Viewport {
  // Default viewport when no keyframes
  const defaultViewport: Viewport = {
    center: { x: 0.5, y: 0.5 },
    zoom: 1.0,
  };

  // Handle empty keyframes
  if (keyframes.length === 0) {
    return defaultViewport;
  }

  // Handle single keyframe
  if (keyframes.length === 1) {
    return keyframeToViewport(keyframes[0]);
  }

  const firstKeyframe = keyframes[0];
  const lastKeyframe = keyframes[keyframes.length - 1];

  // Handle timestamp before first keyframe
  if (timestamp <= firstKeyframe.timestamp) {
    return keyframeToViewport(firstKeyframe);
  }

  // Handle timestamp after last keyframe
  if (timestamp >= lastKeyframe.timestamp) {
    return keyframeToViewport(lastKeyframe);
  }

  // Find adjacent keyframes for interpolation
  const { kf1, kf2 } = findAdjacentKeyframes(keyframes, timestamp);

  // Check for exact match
  if (kf1.timestamp === timestamp) {
    return keyframeToViewport(kf1);
  }

  // Linear interpolation between kf1 and kf2
  const t = (timestamp - kf1.timestamp) / (kf2.timestamp - kf1.timestamp);

  const interpolatedCenter: NormalizedCoord = {
    x: kf1.position.x + (kf2.position.x - kf1.position.x) * t,
    y: kf1.position.y + (kf2.position.y - kf1.position.y) * t,
  };

  const interpolatedZoom = kf1.zoomLevel + (kf2.zoomLevel - kf1.zoomLevel) * t;

  return {
    center: interpolatedCenter,
    zoom: interpolatedZoom,
  };
}

/**
 * Converts a ZoomMarker to a Viewport.
 *
 * @param keyframe - Zoom marker to convert
 * @returns Viewport with center and zoom from the keyframe
 */
function keyframeToViewport(keyframe: ZoomMarker): Viewport {
  return {
    center: { x: keyframe.position.x, y: keyframe.position.y },
    zoom: keyframe.zoomLevel,
  };
}

/**
 * Finds the two adjacent keyframes that bracket the given timestamp.
 * Assumes keyframes has at least 2 elements and timestamp is within range.
 *
 * @param keyframes - Array of zoom markers (sorted by timestamp)
 * @param timestamp - Target timestamp in microseconds
 * @returns Object containing kf1 and kf2 where kf1.timestamp <= timestamp < kf2.timestamp
 */
function findAdjacentKeyframes(
  keyframes: ReadonlyArray<ZoomMarker>,
  timestamp: number
): { kf1: ZoomMarker; kf2: ZoomMarker } {
  // Binary search for efficiency with large keyframe lists
  let low = 0;
  let high = keyframes.length - 1;

  while (low < high - 1) {
    const mid = Math.floor((low + high) / 2);
    if (keyframes[mid].timestamp <= timestamp) {
      low = mid;
    } else {
      high = mid;
    }
  }

  return { kf1: keyframes[low], kf2: keyframes[high] };
}


// ============================================================================
// Zoom Segment Types and Functions
// ============================================================================

import type { ZoomSegment, CursorTrackPoint } from '../types';

/**
 * Interpolates cursor position at a given timestamp from a cursor track.
 * Returns the fallback position if no cursor data is available.
 * Clamps the result to valid normalized coordinates to prevent glitches.
 *
 * @param cursorTrack - Array of cursor track points
 * @param timestamp - Target timestamp in microseconds
 * @param fallbackPosition - Position to use if no cursor data (default: center)
 * @returns Cursor position in normalized coordinates, clamped to [0,1]
 */
function getCursorPositionAtTime(
  cursorTrack: ReadonlyArray<CursorTrackPoint>,
  timestamp: number,
  fallbackPosition: NormalizedCoord = { x: 0.5, y: 0.5 }
): NormalizedCoord {
  if (cursorTrack.length === 0) {
    return fallbackPosition;
  }

  // Filter out invalid cursor positions (outside 0-1 range or at exact 0,0)
  const validTrack = cursorTrack.filter(p => 
    isValidPosition(p.position)
  );

  if (validTrack.length === 0) {
    return fallbackPosition;
  }

  // Handle single point
  if (validTrack.length === 1) {
    return clampPosition(validTrack[0].position);
  }

  const firstPoint = validTrack[0];
  const lastPoint = validTrack[validTrack.length - 1];

  // Handle timestamp before first point - use first point position
  if (timestamp <= firstPoint.timestamp) {
    return clampPosition(firstPoint.position);
  }

  // Handle timestamp after last point - use last point position
  if (timestamp >= lastPoint.timestamp) {
    return clampPosition(lastPoint.position);
  }

  // Binary search for adjacent points
  let low = 0;
  let high = validTrack.length - 1;

  while (low < high - 1) {
    const mid = Math.floor((low + high) / 2);
    if (validTrack[mid].timestamp <= timestamp) {
      low = mid;
    } else {
      high = mid;
    }
  }

  const p1 = validTrack[low];
  const p2 = validTrack[high];

  // Check for large time gaps (> 500ms) - if there's a gap, use the nearest point
  // This prevents interpolating across gaps where the cursor left the window
  const timeGap = p2.timestamp - p1.timestamp;
  if (timeGap > 500_000) {
    // Use the closer point
    const distToP1 = timestamp - p1.timestamp;
    const distToP2 = p2.timestamp - timestamp;
    return clampPosition(distToP1 < distToP2 ? p1.position : p2.position);
  }

  // Check for outlier jumps (cursor teleporting across screen)
  // If detected, use the closer point instead of interpolating
  if (isOutlierJump(p1.position, p2.position, timeGap)) {
    const distToP1 = timestamp - p1.timestamp;
    const distToP2 = p2.timestamp - timestamp;
    return clampPosition(distToP1 < distToP2 ? p1.position : p2.position);
  }

  // Linear interpolation
  const t = (timestamp - p1.timestamp) / (p2.timestamp - p1.timestamp);

  const interpolated: NormalizedCoord = {
    x: p1.position.x + (p2.position.x - p1.position.x) * t,
    y: p1.position.y + (p2.position.y - p1.position.y) * t,
  };

  return clampPosition(interpolated);
}

/**
 * Checks if a position is valid (within reasonable bounds and not at origin).
 */
function isValidPosition(pos: NormalizedCoord): boolean {
  // Check for NaN or undefined
  if (!Number.isFinite(pos.x) || !Number.isFinite(pos.y)) {
    return false;
  }
  // Check for out of bounds (with small tolerance for floating point)
  if (pos.x < -0.01 || pos.x > 1.01 || pos.y < -0.01 || pos.y > 1.01) {
    return false;
  }
  // Check for exact origin (0,0) which often indicates invalid/uninitialized data
  // Use a small epsilon to catch near-zero values that indicate bad data
  if (pos.x < 0.001 && pos.y < 0.001) {
    return false;
  }
  // Check for exact top-right corner (1,0) which can indicate cursor left window
  if (pos.x > 0.999 && pos.y < 0.001) {
    return false;
  }
  return true;
}

/**
 * Checks if a position jump is too large to be a real cursor movement.
 * Large jumps typically indicate the cursor left and re-entered the window.
 */
function isOutlierJump(
  prevPos: NormalizedCoord,
  nextPos: NormalizedCoord,
  timeDeltaUs: number
): boolean {
  // Calculate distance
  const dx = nextPos.x - prevPos.x;
  const dy = nextPos.y - prevPos.y;
  const distance = Math.sqrt(dx * dx + dy * dy);
  
  // Calculate velocity (normalized units per second)
  const timeDeltaSec = timeDeltaUs / 1_000_000;
  if (timeDeltaSec <= 0) return false;
  
  const velocity = distance / timeDeltaSec;
  
  // A velocity > 5 normalized units per second is unrealistic for smooth cursor movement
  // This would mean moving across the entire screen 5 times per second
  // Normal fast cursor movement is around 1-2 units/sec
  return velocity > 5;
}

/**
 * Clamps a position to valid normalized coordinates [0, 1].
 * Also adds a small margin to prevent the zoom from going to the very edge.
 */
function clampPosition(pos: NormalizedCoord): NormalizedCoord {
  // Add a small margin (10%) to prevent zoom from going to the very edge
  // This ensures the zoomed area stays within visible bounds
  const margin = 0.1;
  return {
    x: Math.max(margin, Math.min(1 - margin, pos.x)),
    y: Math.max(margin, Math.min(1 - margin, pos.y)),
  };
}

/**
 * Interpolates viewport from zoom segments at a given timestamp.
 * Zoom segments define time ranges where zoom is applied, with smooth transitions.
 * If cursor track data is available, the zoom follows the cursor.
 * Otherwise, it uses the segment's stored position.
 *
 * Algorithm:
 * - If timestamp is within a zoom segment: return the segment's zoom level centered on cursor/position
 * - If timestamp is in the transition zone (200ms before/after segment): ease in/out
 * - Otherwise: return default viewport (zoom 1.0)
 *
 * @param segments - Array of zoom segments
 * @param timestamp - Target timestamp in microseconds
 * @param cursorTrack - Cursor track for following cursor position (optional)
 * @param transitionDurationUs - Duration of ease in/out transition (default: 200ms)
 * @returns Interpolated viewport at the given timestamp
 */
export function interpolateViewportFromZoomSegments(
  segments: ReadonlyArray<ZoomSegment>,
  timestamp: number,
  cursorTrack: ReadonlyArray<CursorTrackPoint> = [],
  transitionDurationUs: number = 200_000
): Viewport {
  // Default viewport when no segments or outside all segments
  const defaultViewport: Viewport = {
    center: { x: 0.5, y: 0.5 },
    zoom: 1.0,
  };

  if (segments.length === 0) {
    return defaultViewport;
  }

  // Check each segment
  for (const segment of segments) {
    // Get zoom center - use cursor position if available, otherwise use segment's stored position
    // Apply smoothing by averaging nearby cursor positions
    const zoomCenter = getSmoothedCursorPosition(cursorTrack, timestamp, segment.position);

    // Check if we're in the ease-in zone (before segment start)
    if (timestamp >= segment.start - transitionDurationUs && timestamp < segment.start) {
      // Ease in from 1.0 to segment zoom level
      const t = (timestamp - (segment.start - transitionDurationUs)) / transitionDurationUs;
      const easedT = easeInOutCubic(t);
      const zoom = 1.0 + (segment.zoomLevel - 1.0) * easedT;
      // Interpolate center from default to zoom center
      const center: NormalizedCoord = {
        x: 0.5 + (zoomCenter.x - 0.5) * easedT,
        y: 0.5 + (zoomCenter.y - 0.5) * easedT,
      };
      return {
        center,
        zoom,
      };
    }

    // Check if we're inside the segment - use zoom center
    if (timestamp >= segment.start && timestamp <= segment.end) {
      return {
        center: zoomCenter,
        zoom: segment.zoomLevel,
      };
    }

    // Check if we're in the ease-out zone (after segment end)
    if (timestamp > segment.end && timestamp <= segment.end + transitionDurationUs) {
      // Ease out from segment zoom level to 1.0
      const t = (timestamp - segment.end) / transitionDurationUs;
      const easedT = easeInOutCubic(t);
      const zoom = segment.zoomLevel + (1.0 - segment.zoomLevel) * easedT;
      // Interpolate center from zoom center back to default
      const center: NormalizedCoord = {
        x: zoomCenter.x + (0.5 - zoomCenter.x) * easedT,
        y: zoomCenter.y + (0.5 - zoomCenter.y) * easedT,
      };
      return {
        center,
        zoom,
      };
    }
  }

  return defaultViewport;
}

/**
 * Gets a smoothed cursor position by averaging positions over a time window.
 * This prevents sudden jumps in the zoom center.
 * Uses a larger window and more samples for smoother tracking.
 */
function getSmoothedCursorPosition(
  cursorTrack: ReadonlyArray<CursorTrackPoint>,
  timestamp: number,
  fallbackPosition: NormalizedCoord
): NormalizedCoord {
  // Get the base position
  const basePosition = getCursorPositionAtTime(cursorTrack, timestamp, fallbackPosition);
  
  // If no cursor track or very few points, just return the base position
  if (cursorTrack.length < 3) {
    return basePosition;
  }

  // Average positions over a 150ms window for smoother tracking
  // This is long enough to smooth out jitter but short enough to be responsive
  const windowUs = 150_000;
  const positions: NormalizedCoord[] = [];
  
  // Sample positions at regular intervals within the window
  // Use 7 samples for better smoothing
  const samples = 7;
  for (let i = 0; i < samples; i++) {
    const sampleTime = timestamp - windowUs / 2 + (windowUs * i) / (samples - 1);
    const pos = getCursorPositionAtTime(cursorTrack, sampleTime, fallbackPosition);
    positions.push(pos);
  }

  // Calculate weighted average (center samples weighted more)
  // Using Gaussian-like weighting for smooth falloff
  let totalWeight = 0;
  let avgX = 0;
  let avgY = 0;
  
  for (let i = 0; i < positions.length; i++) {
    // Gaussian-like weighting: center samples have more weight
    // sigma = 1.5 gives a nice smooth falloff
    const distFromCenter = Math.abs(i - (samples - 1) / 2);
    const sigma = 1.5;
    const weight = Math.exp(-(distFromCenter * distFromCenter) / (2 * sigma * sigma));
    avgX += positions[i].x * weight;
    avgY += positions[i].y * weight;
    totalWeight += weight;
  }

  if (totalWeight > 0) {
    return clampPosition({
      x: avgX / totalWeight,
      y: avgY / totalWeight,
    });
  }

  return basePosition;
}

/**
 * Cubic ease-in-out function for smooth transitions.
 * @param t - Progress value from 0 to 1
 * @returns Eased value from 0 to 1
 */
function easeInOutCubic(t: number): number {
  return t < 0.5
    ? 4 * t * t * t
    : 1 - Math.pow(-2 * t + 2, 3) / 2;
}

/**
 * Combines zoom segments with manual keyframes to get the final viewport.
 * Zoom segments take precedence over keyframes when active.
 * Zoom segments follow the cursor position for dynamic tracking.
 *
 * @param segments - Array of zoom segments
 * @param keyframes - Array of zoom markers (manual keyframes)
 * @param timestamp - Target timestamp in microseconds
 * @param cursorTrack - Cursor track for following cursor position (optional)
 * @returns Combined viewport at the given timestamp
 */
export function interpolateViewportCombined(
  segments: ReadonlyArray<ZoomSegment>,
  keyframes: ReadonlyArray<ZoomMarker>,
  timestamp: number,
  cursorTrack: ReadonlyArray<CursorTrackPoint> = []
): Viewport {
  // First check if we're in or near a zoom segment
  const segmentViewport = interpolateViewportFromZoomSegments(segments, timestamp, cursorTrack);
  
  // If zoom segment is active (zoom != 1.0), use it
  if (segmentViewport.zoom !== 1.0) {
    return segmentViewport;
  }

  // Otherwise, fall back to keyframe interpolation
  return interpolateViewportFromKeyframes(keyframes, timestamp);
}
